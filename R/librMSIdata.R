#########################################################################
#     rMSI - R package for MSI data handling and visualization
#     Copyright (C) 2014 Pere Rafols Soler
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
############################################################################

#' Load rMSI data from a compressed tar.
#'
#' @param data_file The tar o imzML file containing the MS image in rMSI format or imzML.
#' @param fun_progress This is a callback function to update the progress of loading data. See details for more information.
#' @param fun_label This is a callback function to update the progress bar dialog text.
#' @param close_signal function to be called if the loading process is aborted.
#' @param imzMLChecksum if the binary file checksum must be verified, it can be disabled for convenice with really big files.
#' @param imzMLRename the image name, if NULL a default name based on the file name will be used.
#' @param imzMLSubCoords a Complex vector with the motors coordinates to be included in the ramdisk, if NULL all positions will be used.
#' @param encoding_threads numeber of threads to use during the pngstream encoding process.
#' @param fixBrokenUUID set to FALSE by default to automatically fix an uuid mismatch between the ibd and the imzML files (a warning message will be raised).
#'
#' @return an rMSI object pointing to ramdisk stored data
#'
#' Loads a rMSI data object from .XrMSI file or imzML format. 
#' fun_progress can be NULL or a function with the following prototipe: fun_progress( currentState ). If NULL is used
#' a default command line progress bar is used.
#' This function will be called periodically to monitor the loading status. This is usefull to implement progressbars.
#'
#' @export
LoadMsiData<-function(data_file,
                      fun_progress = NULL, 
                      fun_label = NULL, 
                      close_signal = NULL,
                      imzMLChecksum = F, 
                      imzMLRename = NULL,
                      imzMLSubCoords = NULL,
                      encoding_threads = parallel::detectCores(),
                      fixBrokenUUID = F)
{
  if(!file.exists(data_file))
  {
    stop("File not found\n")
  }
  
  imgData <- NULL
  
  #Default  fun_label()
  if(is.null(fun_label))
  {
    fun_label <- function(text)
    {
      cat(text)
      cat("\n")
    }
  }
  
  pt<-proc.time()

  fileExtension <- unlist(strsplit(basename(data_file), split = "\\."))
  fileExtension <- as.character(fileExtension[length(fileExtension)])
  if( fileExtension == "imzML")
  {
    #Check if the .XrMSI file is already there...
    XrMSI_fname <- basename(data_file)
    XrMSI_fname <- sub("\\.[^.]*$", "", XrMSI_fname)
    XrMSI_fname <- path.expand(file.path(dirname(data_file), paste0(XrMSI_fname, ".XrMSI")))
    if(file.exists(XrMSI_fname))
    {
      #.XrMSI file exists so load it
      fun_label(".XrMSI found, loading data from it...")
      imgData <- import_rMSIXBin(XrMSI_fname)
    }
    else
    {
      #No .XrMSI file so process the imzML
      fun_label(".XrMSI not found, loading imzML data...")
      rMSIobject <- import_imzML(path.expand(data_file),  fun_progress = fun_progress, fun_text = fun_label, close_signal = close_signal, verifyChecksum = imzMLChecksum, subImg_rename = imzMLRename, subImg_Coords = imzMLSubCoords, fixBrokenUUID = fixBrokenUUID)
      rMSIobject <- CNormalizationsAndMeans(list(rMSIobject), encoding_threads, 200, rMSIobject$mass)[[1]]
      imgData <- Ccreate_rMSIXBinData(rMSIobject,encoding_threads)
    }
  }
  else if(fileExtension == "XrMSI")
  {
    #Load the XrMSI file
    imgData <- import_rMSIXBin(data_file, fun_text = fun_label)
  }
  else if(fileExtension == "tar")
  {
    #TODO convert .tar to imzML and load the imzML
    stop("NOT IMPLEMENTED YET: old format .tar files will be supported by automatically converting them to imzML but this is not implemented yet.\n")
    #restore_path <- file.path(dirname(data_file), paste("ramdisk",basename(data_file), sep = "_"))
    #return(import_rMSItar(data_file,restore_path, fun_progress, fun_text = fun_label, close_signal = close_signal))
  }
  else
  {
    stop("The slected file is not valid.\n")
  }
  pt<-proc.time() - pt
  display_processing_time(pt, "Data loading time")
  return(imgData)
}

#' import_rMSIXBin.
#'
#' @param data_file The .XrMSI file containing the MS image in rMSI format.
#' @param fun_text This is a callback function to update the label widget of loading data. See details for more information.
#'  Imports an rMSI data object from an .XrMSI data file
#'  It is recomanded to use rMSI2::LoadMsiData directly instead of this function.
#'  
#' @return   an rMSI data object.
#' @export
#'
import_rMSIXBin<-function(data_file, fun_text = NULL)
{
  
  #Default  fun_text()
  if(is.null(fun_text))
  {
    fun_text <- function(text)
    {
      cat(text)  
      cat("\n")
    }
  }
  
  fun_text("Loading .XrMSI data...")
  img_path  <-  path.expand(dirname(data_file))
  img_fname <- strsplit(basename(data_file), split = ".XrMSI")[[1]] #Set the .XrMSI file
  img <- Cload_rMSIXBinData( img_path, img_fname )
  
  #Check if imzML part exists
  imzML_fname <- path.expand(file.path(img$data$path, paste0( img$data$imzML$file, ".imzML")))
  ibd_fname <- path.expand(file.path(img$data$path, paste0( img$data$imzML$file, ".ibd")))
  if(file.exists(imzML_fname))
  {
    fun_text("Found imzML file, parsing...")
    imzML_XML <- CimzMLParse(imzML_fname)
    img$data$imzML$uuid <- imzML_XML$UUID
    if(imzML_XML$SHA != "")
    {
      img$data$imzML$SHA <- imzML_XML$SHA
    }
    if(imzML_XML$MD5 != "")
    {
      img$data$imzML$MD5 <- imzML_XML$MD5
    }
    img$data$imzML$continuous_mode <- imzML_XML$continuous_mode
    img$data$imzML$mz_dataType <- imzML_XML$mz_dataType
    img$data$imzML$int_dataType <- imzML_XML$int_dataType
    img$data$imzML$run <- imzML_XML$run
    
    #Check imzML UUID
    bincon <- file(description = ibd_fname, open = "rb")
    binUUID <- paste(sprintf("%.2X", readBin(bincon, integer(), 16, size = 1, signed = F)), collapse = "")
    if(binUUID != img$data$imzML$uuid)
    {
      close(bincon)
      stop("ERROR: UUID in imzML file does not match UUID in ibd file")
    }
    close(bincon)
  }
  else
  {
    fun_text("imzML file is not available")
  }

  fun_text("MSI data loaded successfully")
  return(img)
}

#' import_rMSItar.
#'
#' @param data_file The tar file containing the MS image in rMSI format.
#' @param restore_path Where the ramdisk will be created.
#' @param fun_progress This is a callback function to update the progress of loading data. See details for more information.
#' @param fun_text This is a callback function to update the label widget of loading data. See details for more information.
#' @param close_signal function to call if error.
#'
#'  Imports an rMSI data object in a tar data file
#'  It is recomanded to use rMSI2::LoadMsiData directly instead of this function.
#'
#' @return  an rMSI data object.
#' @export
#'
import_rMSItar<-function(data_file, restore_path, fun_progress = NULL, fun_text = NULL, close_signal = NULL )
{
  setPbarValue<-function(progress)
  {
    setTxtProgressBar(pb, progress)
    return(T)
  }

  if(is.null(fun_progress))
  {
    pb<-txtProgressBar(min = 0, max = 100, style = 3 )
    fun_progress <- setPbarValue
  }
  else
  {
    pb<-NULL
  }

  #2 - Image is not preloaded so... the slow way
  if(!is.null(fun_text))
  {
    fun_text("Unpacking data...")
  }

  untar(tarfile = data_file, exdir = restore_path)
  img_path<-file.path(restore_path, "ImgData")


  if( file.exists(file.path(img_path, "uuid.ImgR") ))
  {
    load(file.path(img_path, "uuid.ImgR"))
  }
  else
  {
    #For compatibility with old datasets, just set no id
    uuidObj <- ""
  }
  
  load(file.path(img_path, "mass.ImgR"))
  load(file.path(img_path, "size.ImgR"))
  load(file.path(img_path, "pos.ImgR"))
  if( file.exists(file.path(img_path, "posMotors.ImgR")))
  {
    load(file.path(img_path, "posMotors.ImgR"))
  }
  else
  {
    posMotorsObj <- NULL
  }
  load(file.path(img_path, "mean.SpcR"))
  load(file.path(img_path, "ffnames.ImgR"))
  if(file.exists(file.path(img_path, "pixel_size_um.ImgR")))
  {
    load(file.path(img_path, "pixel_size_um.ImgR"))
  }
  else
  {
    print("Warning: Old image without resolution object. It is set to 9999 um by default!")
    resolutionObj <- 9999
  }
  if(file.exists(file.path(img_path, "normalizations.ImgR")))
  {
    load(file.path(img_path, "normalizations.ImgR"))
  }
  else
  {
    normalizationsObj <- NULL
  }

  if(!is.null(fun_text))
  {
    fun_text("Loading data in the ramdisk...")
  }
  spectra<-list()
  ppStep<-100/length(ffDataNames)
  pp<-0
  for(i in 1:length(ffDataNames))
  {
    ff::ffload(file.path(img_path, ffDataNames[i]), rootpath = restore_path, overwrite = T) #TODO think what to do with deprecated tar files
     #Get Hdd space back asap
    unlink(file.path(img_path, paste0(ffDataNames[i], ".RData")))
    unlink(file.path(img_path, paste0(ffDataNames[i], ".ffData")))
    spectra[[i]]<-ffObj
    names(spectra)[i]<-paste("ramdisk",i,".dat",sep = "")

    pp_ant<-pp
    pp<-pp+ppStep
    if(!is.null(fun_progress) && (round(pp) > round(pp_ant)) )
    {
      #Update progress bar
      if( !fun_progress(pp) )
      {
        return(NULL) #progress bar function must return true if the loading process is to be continued.
      }
    }
  }

  lapply(spectra, ff::open.ff) #TODO deprecated TAR format
  datacube<-list(name = basename(data_file), uuid = uuidObj, mass = massObj,  size = sizeObj,  pos = posObj, pixel_size_um = resolutionObj, mean = meanSpcData, data = spectra)
  if(!is.null(posMotorsObj))
  {
    datacube$posMotors <- posMotorsObj
  }
  if(!is.null(normalizationsObj))
  {
    datacube$normalizations <- normalizationsObj
  }

  unlink(img_path, recursive = T)

  save(datacube, file = file.path(restore_path, "datacube.RImg"))
  if(!is.null(pb))
  {
    close(pb)
  }
  if(!is.null(fun_text))
  {
    fun_text("Done")
  }
  
  class(datacube) <- "rMSIObj"
  return(datacube)
}

#'Remove an rMSI object ramdisk
#'
#' @param img an rMSI object.
#'
#' Removes a rMSI objecte ramdisk.
#'
#' @export
DeleteRamdisk<-function(img)
{
  lapply(img$data, function(x){ ff::close.ff(x) }) #TODO deprecated TAR format
  ramdisk_path <- dirname(attr(attributes(img$data[[1]])$physical, "filename"))
  ramdisk_path_splited <- unlist(strsplit(ramdisk_path, "/"))
  if(.Platform$OS.type == "unix")
  {
    ramdisk_path <- "/"
  }
  else
  {
    ramdisk_path <- ""
  }
  ramdisk_path <- paste0(ramdisk_path,ramdisk_path_splited[1])
  if(length(ramdisk_path_splited) > 1)
  {
    for( i in 2:length(ramdisk_path_splited))
    {
      ramdisk_path<-file.path(ramdisk_path, ramdisk_path_splited[i])
      if( length(grep("ramdisk_", ramdisk_path_splited[i])) > 0 )
      {
        break;
      }
    }
  }
  unlink(ramdisk_path, recursive = T)
}

#' Create an empty rMSI object with defined mass axis and size.
#'
#' @param x_size the number of pixel in X direction.
#' @param y_size the number of pixel in Y direction.
#' @param mass_axis the mass axis.
#' @param pixel_resolution defined pixel size in um.
#' @param img_name the name for the image.
#' @param rMSIXBin_path where the rMSI files will be stored.
#' @param uuid a string containing an universal unique identifier for the image. If it is not provided it will be created using a time code.
#'
#' Creates an empty rMSI object with the provided parameters. This method is usefull to implement importation of new data formats
#' and synthetic datasets to test and develop processing methods and tools.
#'
#' @return the created rMSI object
#' @export
#'
CreateEmptyImage<-function(x_size,
                           y_size,
                           mass_axis,
                           pixel_resolution,
                           img_name = "New empty image",
                           rMSIXBin_path = getwd(),
                           uuid = NULL)
{
  
  #TODO: create empty image with given X Y sizes and mas axis, so this function should actually create the rMSIXBin and the imzML files!
  #Document this and thing about the other CreateEmptyImage() image function
  
  
  img <- CreateEmptyImage( num_of_pixels = x_size*y_size,
                           mass_axis = mass_axis, 
                           pixel_resolution = pixel_resolution, 
                           img_name = img_name, 
                           rMSIXBin_path = rMSIXBin_path, 
                           uuid = uuid)
  
  img$size <- c( x_size, y_size )
  i <- 1
  for( xi in 1:x_size)
  {
    for( yi in 1:y_size)
    {
      img$pos[i,]<- c(xi, yi)
      i<-i+1
    }
  }

  return(img)
}

#' Create an empty rMSI object with defined mass axis and total number of pixels.
#'
#' @param num_of_pixels Total number of spectrums/pixels.
#' @param mass_axis the mass axis.
#' @param pixel_resolution defined pixel size in um.
#' @param img_name the name for the image.
#' @param rMSIXBin_path where the rMSI files will be stored.
#' @param uuid a string containing an universal unique identifier for the image. If it is not provided it will be created using a time code.
#'
#' Creates an empty rMSI object with the provided parameters. This method is usefull to implement importation of new data formats
#' and synthetic datasets to test and develop processing methods and tools.
#' img$size is initialized with c(NA, NA) and the pos matrix with NA coords. Size and pos matrix must be filled by user.
#'
#' @return the created rMSI object
#' @export
#'
CreateEmptyImage<-function(num_of_pixels,
                           mass_axis, 
                           pixel_resolution, 
                           img_name = "New empty image", 
                           rMSIXBin_path = getwd(), 
                           uuid = NULL)
{
  img<-list()
  class(img) <- "rMSIObj"
  img$rMSI_format_version <- 2
  img$name <- img_name
  img$mass <- mass_axis
  img$size <- c( NA, NA )
  names(img$size) <- c("x", "y")

  #Prepare the pos matrix
  img$pos <- matrix( NA, ncol = 2, nrow = num_of_pixels )
  img$posMotors <- matrix( NA, ncol = 2, nrow = num_of_pixels )
  colnames(img$pos)<- c("x", "y")
  colnames(img$posMotors)<- c("x", "y")
  
  img$pixel_size_um <-  pixel_resolution
  img$mean <- rep(0, length(mass_axis))
  img$base <- rep(0, length(mass_axis))

  #Prepare an empty datacube
  img$data <- list()
  class(img$data) <- "rMSIData"
  img$data$path <- rMSIXBin_path
  
  img$data$rMSIXBin <- list() 
  class(img$data$rMSIXBin) <- "rMSIXBinData"
  img$data$rMSIXBin$file <- NULL
  img$data$rMSIXBin$uuid <- uuid_timebased()
  img$data$rMSIXBin$imgStream <- data.frame( 
                                            ByteLength = rep(NA, length(mass_axis)), #The encoded byte length of each m/z channel image
                                            ByteOffset = rep(NA, length(mass_axis)) #The offset in bytes of each m/z channel image in the imgStream 
                                            )
  class(img$data$rMSIXBin$imgStream) <- "imgStream"
  
  img$data$imzML <- list()
  class(img$data$imzML) <- "imzMLData"
  img$data$imzML$file <- NULL
  if(is.null(uuid))
  {
    img$data$imzML$uuid <- uuid_timebased()
  }
  else
  {
    img$data$imzML$uuid <- uuid  
  }
  
  #Init not availble imZML data to NULL (will be set latter outside this function)
  img$data$imzML$SHA <- NULL
  img$data$imzML$MD5 <- NULL
  img$data$imzML$continuous_mode <- NULL
  img$data$imzML$mz_dataType <- NULL
  img$data$imzML$int_dataType <- NULL
  img$data$imzML$run <- NULL

  img$data$peaklist <- list()
  class(img$data$peaklist) <- "peakList"
  #The peaklist field are created outside this function.
  
  img$normalizations <- data.frame();
  
  return(img)
}

#' AverageSpectrum.
#' Computes the average spectrum of a whole rMSI image.
#'
#' @param img the rMSI image object.
#'
#' @return A vector with the average spectrum intensities. Masses are the same as the rMSI object.
#' @export
#'
  AverageSpectrum <- function(img)
{
  cat("Calculating Average Spectrum...\n")
  avgSpectrum <- tryCatch(
    {
      return(rMSIproc::AverageSpectrum(img, NumOfThreads = min(parallel::detectCores()/2, 6)))
    },
    warning = function(war)
    {
        print(paste("WARNING in rMSI AverageSpectrum calling rMSIproc::AverageSpectrum: ",war))
        return(NULL)
    }, 
    error = function(err) 
    {
      #No rMSIproc::AverageSpectrum present... so using rMSI slow average
      pbavg <- txtProgressBar(min = 0, max = length(img$data), style = 3)
      avgI <- rep(0, length(img$mass))
      for( i in 1:length(img$data))
      {
        setTxtProgressBar(pbavg, i)
        avgI <- avgI +  colSums(img$data[[i]][,])
      }
      avgI <- avgI/nrow(img$pos)
      close(pbavg)
      return(avgI)
    })
  return(avgSpectrum)
}

#' BaseSpectrum.
#' Computes the base spectrum of a whole rMSI image where the intensity value
#' for each mass bin is calculated as the maxium of all mass channels.
#'
#' @param img the rMSI image object.
#'
#' @return A vector with the base spectrum intensities. Masses are the same as the rMSI object.
#' @export
#'
BaseSpectrum <- function(img)
{
  cat("Calculating Base Spectrum...\n")
  pb <- txtProgressBar(min = 0, max = length(img$data), style = 3)
  maxSub <- rep(0, length(img$mass))
  for( i in 1:length(img$data))
  {
    setTxtProgressBar(pb, i)
    maxSub <- maxSub + apply(img$data[[i]][,], 2, max)
  }
  close(pb)
  return(maxSub)
}

#' SortIDsByAcquisition: Order the rMSI pixel IDs according the acqusition sequence (first acquired pixel is the first one).
#'
#' @param img a rMSI image.
#'
#' @return a vector of ID's ordered acording acquisiton.
#' @export
#'
SortIDsByAcquisition <- function(img)
{
  idxArray <- matrix( c(1:nrow(img$pos), img$pos[,"x"], img$pos[,"y"]), nrow = nrow(img$pos), ncol = 3, byrow = F )
  colnames(idxArray) <- c("id", "x", "y")
  idxArray <- idxArray[order(idxArray[,"y"], idxArray[,"x"]), ]
  return(idxArray[,"id"])
}


#' PlotClusterImage.
#' Plot a segmentation image with the user-given clusters.
#'
#' @param posMat a two columns matrix where first column ara the x coodrinates of values and second column the y coordinates.
#' @param clusters a vector with integer number according the cluster of each pixel.
#' @param rotate rotation to apply.
#' @param pixel_size_um the pixel resolution in um.
#' @param labels_x x coordinates of text labels optionally overlaid to the plot.
#' @param labels_y y coordinates of text labels optionally overlaid to the plot.
#' @param labels_text text labels optionally overlaid to the plot.
#'
#' @return a vector with the used color for each cluster sorted according clustering numering in assending order.
#' @export
#'
PlotClusterImage <- function( posMat, clusters,  rotate = 0,  pixel_size_um = 100,
                              labels_x = NULL, labels_y = NULL, labels_text = NULL)
{
  img <- list()
  img$pos <- posMat
  colnames(img$pos) <- c("x", "y")
  img$size <- c(max(img$pos[ ,"x"]), max(img$pos[ ,"y"]))
  names(img$size) <- c("x", "y")
  img$pixel_size_um <- pixel_size_um

  #Prepare image matrix
  zplots<-matrix(0, nrow=img$size["x"], ncol=img$size["y"]) #Now I'm using a zero instead of NA to display a completely black background
  for( i in 1:nrow(img$pos))
  {
    zplots[img$pos[ i , "x" ], img$pos[ i , "y" ]] <- clusters[i]
  }

  #Create the raster
  my_raster <- terra::rast( nrow = ncol(zplots), ncol = nrow(zplots), xmin= 0, xmax= nrow(zplots), ymin= 0, ymax= ncol(zplots))
  terra::values(my_raster) <- as.vector(zplots)
  rm(zplots)

  #Put zplots matrix and some metadata in a list
  img_sgn <- list(raster = my_raster, mass = "", tolerance = 0, cal_resolution = img$pixel_size_um)
  rm(my_raster)

  oldPar <- par(no.readonly = T)
  raster_RGB<-.BuildSingleIonRGBImage(img_sgn, XResLevel = 3, light = 5)
  .plotMassImageRGB(raster_RGB, cal_um2pixels = img$pixel_size_um, rotation = rotate, display_axes = F, display_syscoords = F)

  #Get the colors used for clusters as a plotable form (RGB code) using the same rMSI internal function as raster image
  colras <- terra::rast( nrow = 1, ncol = 1+length(unique(clusters)))
  terra::values(colras) <- sort(c(0, unique(clusters)))
  rgbColRas <- .ReMappingIntensity2HSV(colras, value_multiplier = 5)
  clusterColors <- c()
  Rchannel <- terra::values(rgbColRas)[,1]
  Gchannel <- terra::values(rgbColRas)[,2]
  Bchannel <- terra::values(rgbColRas)[,3]
  for( i in 1:length(unique(clusters))) #I'm avoiding the fist values because is the zero used to draw the background
  {
    clusterColors <- c(clusterColors, rgb( Rchannel[i + 1], Gchannel[i + 1], Bchannel[i + 1], 255, maxColorValue = 255))
  }

  text( x = labels_x, y = labels_y, labels = labels_text , adj = c(0.5, 0.0))
  par(oldPar)
  
  return(clusterColors)
}


#' PlotValues.
#'
#' Plot values in a image using the same methods as plotting an MS image.
#' The raster position of each value is definied in posMat.
#'
#' @param posMat a two columns matrix where first column ara the x coodrinates of values and second column the y coordinates.
#' @param values the values to plot.
#' @param rotate rotation to apply.
#' @param scale_title a text label for the color scale.
#' @param pixel_size_um the pixel resolution in um.
#' @param vlight the lighting of the plotted image.
#' @param labels_x x coordinates of text labels optionally overlaid to the plot.
#' @param labels_y y coordinates of text labels optionally overlaid to the plot.
#' @param labels_text text labels optionally overlaid to the plot.
#'
#' @export
#'
PlotValues <- function(posMat, values, rotate = 0, scale_title = "", pixel_size_um = 100, vlight = 5,
                       labels_x = NULL, labels_y = NULL, labels_text = NULL)
{
  fooImg <- list()
  fooImg$pos <- posMat
  colnames(fooImg$pos) <- c("x", "y")
  fooImg$size <- c(max(fooImg$pos[ ,"x"]), max(fooImg$pos[ ,"y"]))
  names(fooImg$size) <- c("x", "y")
  fooImg$pixel_size_um <- pixel_size_um
  PlotTICImage( fooImg, values, rotate, scale_title, vlight, labels_x = labels_x, labels_y = labels_y, labels_text = labels_text )
}

#' PlotTICImage.
#'
#' @param img an rMSI object.
#' @param TICs a vector of TIC values ordered acording pos array in img object.
#' @param rotate image rotation in degrees, possible values are: 0, 90, 180 and 270.
#' @param scale_title the title to show in scale axis (TIC by default).
#' @param vlight the lighting of the plotted image.
#' @param labels_x x coordinates of text labels optionally overlaid to the plot.
#' @param labels_y y coordinates of text labels optionally overlaid to the plot.
#' @param labels_text text labels optionally overlaid to the plot.
#'
#' @export
#'
PlotTICImage <- function(img, TICs = NULL, rotate = 0, scale_title = "TIC", vlight = 5, 
                         labels_x = NULL, labels_y = NULL, labels_text = NULL)
{
  #Calculate TICs
  if(is.null(TICs))
  {
    pb<-txtProgressBar(min = 0, max = length(img$data), style = 3 )
    setTxtProgressBar(pb, 0)
    TICs <- c()
    for( i in 1:length(img$data))
    {
      TICs <- c(TICs, rowSums(img$data[[i]][,]))
      setTxtProgressBar(pb, i)
    }
    close(pb)
  }

  #Do not plot infinites
  TICs[which(is.infinite(TICs))] <- 0

  #Prepare image matrix
  zplots<-matrix(0, nrow=img$size["x"], ncol=img$size["y"]) #Now I'm using a zero instead of NA to display a completely black background
  for( i in 1:nrow(img$pos))
  {
    zplots[img$pos[ i , "x" ], img$pos[ i , "y" ]] <- TICs[i]
  }

  #Create the raster
  my_raster <- terra::rast( nrow = ncol(zplots), ncol = nrow(zplots), xmin= 0, xmax= nrow(zplots), ymin= 0, ymax= ncol(zplots))
  terra::values(my_raster) <- as.vector(zplots)
  rm(zplots)

  #Put zplots matrix and some metadata in a list
  img_sgn <- list(raster = my_raster, mass = scale_title, tolerance = 0, cal_resolution = img$pixel_size_um)
  rm(my_raster)

  raster_RGB<-.BuildSingleIonRGBImage(img_sgn, XResLevel = 3, light = vlight)

  oldPar<- par(no.readonly = T)
  
  layout( matrix( 2:1, ncol = 2, nrow = 1, byrow = TRUE ), widths = c(7, rep(1, 2)) )
  .plotIntensityScale(img_sgn, light =  5)
  .plotMassImageRGB(raster_RGB, cal_um2pixels = img$pixel_size_um, rotation = rotate, display_axes = F, display_syscoords = F)
  
  text( x = labels_x, y = labels_y, labels = labels_text , adj = c(0.5, 0.0))
  
  par(oldPar)
}

#' plotParamAcqOrdered.
#'
#' @param img rMSI object from wich data must be ploted.
#' @param Param a vector of elements to plot.
#' @param yAxisLabel.
#'
#' Param will be ploted ordered according the order of pixels in MALDI acqusition.
#'
#' @export
#'
plotParamAcqOrdered <- function( img, Param, yAxisLabel = "Param" )
{
  idxArray <- matrix( c(1:nrow(img$pos), img$pos[,"x"], img$pos[,"y"]), nrow = nrow(img$pos), ncol = 3, byrow = F )
  colnames(idxArray) <- c("id", "x", "y")
  idxArray <- idxArray[order(idxArray[,"y"], idxArray[,"x"]), ]
  plot(Param[idxArray[,"id"]], type="l", col ="red", ylab = yAxisLabel, xlab = "Pixel" )
}

#' remap2ImageCoords.
#'
#' @param dataPos a pos matrix as it is in rMSI data object.
#'
#' This function should be only used to implement data importers from foreign formats.
#' This functions maps a MALDI motors coors space to a image coord space.
#' dataPos matrix is a two columns matrix where first column stores x positions and second y pixel positions.
#' a remapped dataPos matrix do not contain empty raster positions neighter offsets.
#'
#' @return the dataPos matrix remapped.
#' @export
#'
remap2ImageCoords <- function(dataPos)
{
  #1- Calc offsets and subtract it
  x_offset<-min(dataPos[,"x"])
  y_offset<-min(dataPos[,"y"])
  for(i in 1:nrow(dataPos))
  {
    dataPos[i, "x"] <- dataPos[i, "x"] - x_offset + 1
    dataPos[i, "y"] <- dataPos[i, "y"] - y_offset + 1
  }

  #2- Compute Motor coords range
  x_size<-max(dataPos[,"x"])
  y_size<-max(dataPos[,"y"])

  #3- Map MALDI motor coords to image cords (1-pixels steps)
  #It is important to map MALDI motors coords to image coords.
  #Otherwise, null extra pixels may be added leading to bad reconstruction
  px_map <- matrix( 0, nrow = x_size, ncol = y_size)
  for(i in 1:nrow(dataPos))
  {
    xi <- dataPos[i, "x"]
    yi <- dataPos[i, "y"]
    px_map[xi, yi]<- i
  }

  colNull <- which( base::colSums(px_map) == 0)
  rowNull <- which( base::rowSums(px_map) == 0)
  remap<-FALSE
  if( length(colNull) > 0 && length(rowNull) > 0 )
  {
    px_map_ <- px_map[ -rowNull , -colNull ]
    remap<-TRUE
  }
  if( length(colNull) > 0 && length(rowNull) == 0 )
  {
    px_map_ <- px_map[ , -colNull ]
    remap<-TRUE
  }
  if( length(colNull) == 0 && length(rowNull) > 0 )
  {
    px_map_ <- px_map[ -rowNull , ]
    remap<-TRUE
  }

  if(remap)
  {
    for(ix in 1:nrow(px_map_))
    {
      for(iy in 1:ncol(px_map_))
      {
        if(px_map_[ix, iy] > 0)
        {
          dataPos[px_map_[ix, iy], "x"] <- ix
          dataPos[px_map_[ix, iy], "y"] <- iy
        }
      }
    }
  }

  return(dataPos)
}

#' .controlled_loadAbort.
#'
#' @param text to be promt at R console
#' @param close_signal the function to call
#'
.controlled_loadAbort <- function(text, close_signal = NULL)
{
  if(!is.null(close_signal))
  {
    close_signal()
  }
  stop(text)
}

#' ParseBrukerXML.
#'
#' Reads a Bruker's xml file exported using fleximaging.
#' A list is returned where each element in the list is named according the ROI name.
#' Each element in the list consists in a data.frame with the pixels XY coordinates inside each ROI.
#'
#' @param xml_path the full path where XML file is stored.
#'
#' @return ROI pixel coordinates arranged in a named list.
#' @export
#' 
ParseBrukerXML <- function(xml_path)
{
  roilst <- CparseBrukerXML(path.expand(xml_path))
  
  if( !is.null(roilst$Error))
  {
    stop(roilst$Error)
  }
  
  return(roilst)
}

#' ReadBrukerRoiXML.
#' 
#' Reads a Bruker ROI XML file and matches it to an rMSI image object.
#' A list of rMSI ID's contained in each Bruker's ROI will be returned.
#'
#' @param img an rMSI MS image object.
#' @param xml_file a full path to a Bruker XML ROI file.
#'
#' @return a list containing lists of ID's for each ROI.
#' @export
#'
ReadBrukerRoiXML <- function(img, xml_file)
{
  if( is.null(img$posMotors))
  {
    stop("ERROR: image posMotros matrix not available.\nYou need to re-import MS data using a recent verison of rMSI.\n")
  }
  
  spectraListRois <- ParseBrukerXML(xml_file)
  lstRois <- list()
  imPosMat <- complex( real = img$posMotors[, "x"], imaginary = img$posMotors[, "y"])
  
  for( i in 1:length(spectraListRois))
  {
    cat(paste0("Parsing ROI ", i, " of ", length(spectraListRois), "\n"))
    lstRoisAux <- list(name = spectraListRois[[i]]$name, id = c())
    for( j in 1:nrow(spectraListRois[[i]]$pos))
    {
      #Extract original X Y Bruker Coords
      imCoord <- complex(real = spectraListRois[[i]]$pos$x[j], imaginary = spectraListRois[[i]]$pos$y[j])
      
      #Look for this Bruker coords in image pos matrix
      matchXY <- which(imPosMat == imCoord)
      if( length(matchXY) > 0)
      {
        lstRoisAux$id <- c( lstRoisAux$id, matchXY[1])
        if(  length(matchXY) > 1 )
        {
          cat(paste0("WARNING: roi ", spectraListRois[[i]]$name, " coordinates x", Re(imCoord), " , y", Im(imCoord), " are duplicated.\n" ))
        }
      }
    }
    
    if( length( lstRoisAux$id ) > 0 )
    {
      lstRoisAux$id <- sort( lstRoisAux$id, decreasing = F) #Sort ID's by assending order to get a faster disk access time
      lstRois[[(length(lstRois) + 1)]] <- lstRoisAux
    }
    else
    {
      cat(paste0("WARNING: deleting roi ",  spectraListRois[[i]]$name, " because it does not contain any pixel in the image.\n" ))
    }
  }
  
  return(lstRois)
}

#' Trim_imzMLData.
#' 
#' Create a partial copy of an imZML file by coping only the data that matches the mass and pixel ID filters.
#'
#' @param input_data_file complete path to an input imzML file.
#' @param output_data_file complete path to an output imzML file (will be overwritten). 
#' @param keepPixelIDs the pixel ID's to kept in the output imzML file.
#' @param mass_min the minimum value of the output mass range.
#' @param mass_max the maximum value of the output mass range.
#' @param intensity_trim trim intensities below this value.
#' @export
#'
Trim_imzMLData <- function(input_data_file, output_data_file, keepPixelIDs = NULL, mass_min = NULL, mass_max = NULL, intensity_trim = 0)
{
  #TODO test this method with continuous data!
  
  if(is.null(keepPixelIDs) && is.null(mass_min) && is.null(mass_max))
  {
    stop("Some filter must be set!.\n")
  }
  
  in_img <- import_imzML(imzML_File = input_data_file, convertProcessed2Continuous = T)
  
  #Remove extension if supplied
  outfname <- basename(output_data_file)
  outfname <- sub("\\.[^.]*$", "", outfname)
  output_data_file <- path.expand(file.path(dirname(output_data_file), outfname))
  
  if(is.null(keepPixelIDs))
  {
    #ID filter not set so take all the IDs
    keepPixelIDs <- 1:nrow(in_img$pos)
  }
  out_run_data <- in_img$data$imzML$run[keepPixelIDs, ]
  
  if(is.null(mass_min))
  {
    #Mass min not set so use data min
    mass_min <- in_img$mass[1]
  }
  
  if(is.null(mass_max))
  {
    #Mass max not set so use data max
    mass_max <- in_img$mass[length(in_img$mass)]
  }
  
  
  cat("Creating the sub-image ibd file...\n")
  if(!dir.exists(dirname(output_data_file)))
  {
    dir.create(dirname(output_data_file), showWarnings = F, recursive = T)
  }

  newUUID <- uuid_timebased()
  CimzMLBinCreateNewIBD(paste0(output_data_file, ".ibd"), newUUID)
  
  pb <- txtProgressBar(min = 0, max = nrow(out_run_data), style = 3)
  emptyPixels <- c()
  for(i in 1:nrow(out_run_data))
  {
    mass <- CimzMLBinReadMass(path.expand(file.path(in_img$data$path, paste0(in_img$data$imzML$file, ".ibd"))),
                                      1, 
                                      out_run_data$mzLength[i], 
                                      out_run_data$mzOffset[i], 
                                      in_img$data$imzML$mz_dataType, 
                                      in_img$data$imzML$continuous_mode)
    
    intensity <- CimzMLBinReadIntensity(path.expand(file.path(in_img$data$path, paste0(in_img$data$imzML$file, ".ibd"))),
                                      1, 
                                      out_run_data$intLength[i], 
                                      out_run_data$intOffset[i], 
                                      in_img$data$imzML$int_dataType, 
                                      in_img$data$imzML$continuous_mode)
    
    #Trim mass channel and intensity
    intensity <- intensity - intensity_trim
    keepMassChannels <- which( ((mass >= mass_min) & (mass <= mass_max)) & (intensity >= 0) ) 
    if(length(keepMassChannels) > 10) #At least 10 datapoints to be considered a non-empty spectrum
    {
      mass <- mass[keepMassChannels]
      intensity <- intensity[keepMassChannels]
      
      
      if(!in_img$data$imzML$continuous_mode || i == 1)
      {
        out_run_data$mzOffset[i] <- CimzMLBinAppendMass(paste0(output_data_file, ".ibd"), in_img$data$imzML$mz_dataType, mass )
        out_run_data$mzLength[i] <- length(mass)
      }
      
      out_run_data$intOffset[i] <- CimzMLBinAppendIntensity(paste0(output_data_file, ".ibd"), in_img$data$imzML$int_dataType, intensity )
      out_run_data$intLength[i] <- length(intensity)  
    }
    else
    {
      emptyPixels <- c(emptyPixels, i)
    }
    
    setTxtProgressBar(pb, i)
  }
  close(pb)
  
  if(length(emptyPixels) > 0)
  {
    out_run_data <- out_run_data[-emptyPixels,]
  }
  
  cat("Calculating MD5 checksum...\n")
  checksum_md5 <- toupper(digest::digest( paste0(output_data_file, ".ibd"), algo = "md5", file = T))
  
  cat("Creating the sub-image imzML file...\n")
  imgInfo <- list( UUID = newUUID, 
                   continuous_mode = in_img$data$imzML$continuous_mode, 
                   MD5 = checksum_md5,
                   SHA = "",
                   mz_dataType = in_img$data$imzML$mz_dataType,
                   compression_mz = FALSE,
                   int_dataType = in_img$data$imzML$int_dataType,
                   compression_int = FALSE,
                   pixel_size_um = in_img$pixel_size_um,
                   run_data = out_run_data )
  
  rMSI2:::CimzMLStore(paste0(output_data_file, ".imzML"), imgInfo )
  
  cat("imzML Export completed\n")
}

#' ROIAverageSpectra.
#' 
#' Calculates the average spectrum within each roi.
#'
#' @param img an rMSI object.
#' @param roi_list a roi list in the format returned by ReadBrukerRoiXML().
#'
#' @return all rois average spectra arranges in a list.
#' @export
#'
ROIAverageSpectra <- function( img, roi_list )
{
  if(length(roi_list) == 0)
  {
    stop("Error: emtpy region list\n")
  }
  
  cat("Calculating Average Spectra of ROI's...\n")
  rois_avg <- lapply(roi_list, function(x){
    cat(paste0("Processing ROI ", x$name, "\n"))
    list(name = x$name, mean = ROIAverageSpectraByIds(img, x$id) )
    })
  
  return(rois_avg)
}

#' ROIAverageSpectraByIds.
#' 
#' Calculates the average spectrum within each roi specified by a vector of pixel ID's
#'
#' @param img an rMSI object.
#' @param Ids Identifiers of spectra to use for average calculation.
#' @param maxMemMB maximum memory usage during spectral buffering in MB.
#'
#' @return the ROI average spectrum.
#' @export
#'
ROIAverageSpectraByIds <- function( img, Ids, maxMemMB = 200 )
{
  cat("Calculating Average Spectra of slected pixels...\n")
  pb <- txtProgressBar(min = 0, max = length(Ids), initial = 0, style = 3)
  roi_avg <-  rep(0, length(img$mass))
  maxPixels <- max(floor((maxMemMB * 1024 * 1024) / (length(img$mass)*8.0)), 1)
  start_i <- 1
  bEnd <- FALSE
  while (!bEnd)
  {
    remaining_ids <-  length(Ids) - start_i + 1
    if(remaining_ids > maxPixels )
    {
      load_ids <- Ids[start_i:(start_i + maxPixels -1)]
      start_i <- start_i + maxPixels
      setTxtProgressBar(pb, start_i -1)
    }
    else
    {
      load_ids <- Ids[start_i:length(Ids)]
      setTxtProgressBar(pb, length(Ids))
      bEnd <- TRUE
    }
    dm <- loadImgChunkFromIds(img, load_ids)
    dm <- dm / as.numeric(length(Ids))
    roi_avg <- roi_avg + apply(dm, 2, sum)
    rm(dm)
  } 
  gc()
  close(pb) 
  
  return(roi_avg)
}

#' uuid.
#' 
#' Generates a timecode-based 16-bytes UUID.
#' The generated bytes are generated using the following pattern:
#' bytes 0 and 1: Year
#' byte 2: Month
#' byte 3: Day
#' byte 4: Hour
#' byte 5: Minute
#' byte 6: Second
#' bytes 7 to 15: random.
#'
#' @return the generated UUID encoded in a text string.
#'
uuid_timebased <- function()
{
  currentTime <- Sys.time()
  sUUID <- sprintf( "%04X", as.integer( format(currentTime, "%Y")))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%m"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%d"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%H"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%M"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%S"))))
  sUUID <-paste0(sUUID, paste0(sprintf("%02X",sample(0:255, 9)), collapse = ""))
  
  Sys.sleep(1) #force to sleep one seconf to ensure each execition provides a unique uuid
  
  return(sUUID)
}

#Function to display processing time properly
display_processing_time <- function(time_elapsed, message)
{
  if(class(time_elapsed) != "proc_time")
  {
    stop("time_elapsed invalid class time")  
  }
  
  dsec <- time_elapsed["elapsed"]
  hours <- floor(dsec / 3600)
  minutes <- floor((dsec - 3600 * hours) / 60)
  seconds <- round(dsec - 3600*hours - 60*minutes, digits = 3)
  cat(paste0(message, ": "))
  if(hours > 0) cat(paste0(hours, " hours,\t"))
  if(minutes > 0 || hours > 0) cat(paste0(minutes, " minutes,\t"))
  cat(paste0(seconds, " seconds\n"))
}

#' readimzML_singlePixelPeakList.
#' 
#' Reads a single pixel peaklist directely from an imzML file in processed mode.
#' Extra peak information will be available if the peak list was previously stored in the rMSI peak list format. 
#' The extra peak infor include peak area, SNR and bin size.
#'
#' @param imzML_file path to the imzML file containing the peak list (with or without extension).
#' @param pixel_id the pixel ID in the imzML to read.
#'
#' @return a list containg the peak information for the given pixel.
#' @export
#'
readimzML_singlePixelPeakList <- function(imzML_file, pixel_id)
{
  imzML_file <- as.character(strsplit(imzML_file, split = ".imzML", fixed = T)[[1]]) 
  imzMLDesc <- CimzMLParse(path.expand(paste0(imzML_file, ".imzML")))
  peakList <- CimzMLReadPeakList(path.expand(paste0(imzML_file, ".ibd")), imzMLDesc, pixel_id-1) #C-style indexing so -1  
  return ( peakList )
}
